var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useCallback, Fragment } from "react";
import { Typography } from "@mui/material";
import { format, eachMinuteOfInterval, isSameDay, differenceInDays, isToday, isWithinInterval, setHours, setMinutes, isBefore, isAfter, startOfDay, endOfDay, addDays, addMinutes, } from "date-fns";
import TodayTypo from "../components/common/TodayTypo";
import EventItem from "../components/events/EventItem";
import { useAppState } from "../hooks/useAppState";
import { calcCellHeight, calcMinuteHeight, getResourcedEvents, } from "../helpers/generals";
import { WithResources } from "../components/common/WithResources";
import { Cell } from "../components/common/Cell";
import TodayEvents from "../components/events/TodayEvents";
import { TableGrid } from "../styles/styles";
import { MULTI_DAY_EVENT_HEIGHT } from "../helpers/constants";
const Day = () => {
    const { day, selectedDate, events, height, triggerDialog, remoteEvents, triggerLoading, handleState, resources, resourceFields, fields, direction, locale, } = useAppState();
    const { startHour, endHour, step, cellRenderer } = day;
    const START_TIME = setMinutes(setHours(selectedDate, startHour), 0);
    const END_TIME = setMinutes(setHours(selectedDate, endHour), 0);
    const hours = eachMinuteOfInterval({
        start: START_TIME,
        end: END_TIME,
    }, { step: step });
    const CELL_HEIGHT = calcCellHeight(height, hours.length);
    const MINUTE_HEIGHT = calcMinuteHeight(CELL_HEIGHT, step);
    const todayEvents = events.sort((b, a) => a.end.getTime() - b.end.getTime());
    const fetchEvents = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        try {
            triggerLoading(true);
            const start = addDays(START_TIME, -1);
            const end = addDays(END_TIME, 1);
            const query = `?start=${start}&end=${end}`;
            const events = yield remoteEvents(query);
            if (events && (events === null || events === void 0 ? void 0 : events.length)) {
                handleState(events, "events");
            }
        }
        catch (error) {
            throw error;
        }
        finally {
            triggerLoading(false);
        }
        // eslint-disable-next-line
    }), [selectedDate]);
    useEffect(() => {
        if (remoteEvents instanceof Function) {
            fetchEvents();
        }
        // eslint-disable-next-line
    }, [fetchEvents]);
    const renderMultiDayEvents = (events) => {
        const multiDays = events.filter((e) => differenceInDays(e.end, e.start) > 0 &&
            isWithinInterval(selectedDate, {
                start: startOfDay(e.start),
                end: endOfDay(e.end),
            }));
        return (_jsx("div", Object.assign({ className: "rs__block_col", style: { height: MULTI_DAY_EVENT_HEIGHT * multiDays.length } }, { children: multiDays.map((event, i) => {
                const hasPrev = isBefore(event.start, startOfDay(selectedDate));
                const hasNext = isAfter(event.end, endOfDay(selectedDate));
                return (_jsx("div", Object.assign({ className: "rs__multi_day", style: {
                        top: i * MULTI_DAY_EVENT_HEIGHT,
                        width: "100%",
                    } }, { children: _jsx(EventItem, { event: event, multiday: true, hasPrev: hasPrev, hasNext: hasNext }, void 0) }), event.event_id));
            }) }), void 0));
    };
    const renderTable = (resource) => {
        let recousedEvents = todayEvents;
        if (resource) {
            recousedEvents = getResourcedEvents(todayEvents, resource, resourceFields, fields);
        }
        const allWeekMulti = events.filter((e) => differenceInDays(e.end, e.start) > 0 &&
            isWithinInterval(selectedDate, {
                start: startOfDay(e.start),
                end: endOfDay(e.end),
            }));
        // Equalizing multi-day section height
        const headerHeight = MULTI_DAY_EVENT_HEIGHT * allWeekMulti.length + 45;
        return (_jsxs(TableGrid, Object.assign({ days: 1 }, { children: [_jsx("span", { className: "rs__cell" }, void 0),
                _jsxs("span", Object.assign({ className: `rs__cell rs__header ${isToday(selectedDate) ? "rs__today_cell" : ""}`, style: { height: headerHeight } }, { children: [_jsx(TodayTypo, { date: selectedDate }, void 0), renderMultiDayEvents(recousedEvents)] }), void 0),
                hours.map((h, i) => {
                    const start = new Date(`${format(selectedDate, "yyyy MM dd")} ${format(h, "hh:mm a")}`);
                    const end = new Date(`${format(selectedDate, "yyyy MM dd")} ${format(addMinutes(h, step), "hh:mm a")}`);
                    const field = resourceFields.idField;
                    return (_jsxs(Fragment, { children: [_jsx("span", Object.assign({ className: "rs__cell rs__header rs__time", style: { height: CELL_HEIGHT } }, { children: _jsx(Typography, Object.assign({ variant: "caption" }, { children: format(h, "hh:mm a", { locale: locale }) }), void 0) }), void 0),
                            _jsxs("span", Object.assign({ className: `rs__cell ${isToday(selectedDate) ? "rs__today_cell" : ""}` }, { children: [i === 0 && (_jsx(TodayEvents, { todayEvents: recousedEvents.filter((e) => !differenceInDays(e.end, e.start) &&
                                            isSameDay(selectedDate, e.start)), today: selectedDate, minuteHeight: MINUTE_HEIGHT, startHour: startHour, step: step, direction: direction }, void 0)),
                                    cellRenderer ? (cellRenderer({
                                        day: selectedDate,
                                        start,
                                        end,
                                        height: CELL_HEIGHT,
                                        onClick: () => triggerDialog(true, {
                                            start,
                                            end,
                                            [field]: resource ? resource[field] : null,
                                        }),
                                        [field]: resource ? resource[field] : null,
                                    })) : (_jsx(Cell, { start: start, end: end, resourceKey: field, resourceVal: resource ? resource[field] : null }, void 0))] }), void 0)] }, i));
                })] }), void 0));
    };
    return resources.length ? (_jsx(WithResources, { span: 2, renderChildren: renderTable }, void 0)) : (renderTable());
};
export { Day };
