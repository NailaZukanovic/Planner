var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Fragment, useState } from "react";
import { Dialog, DialogContent, DialogTitle, DialogActions, Button, Grid, useTheme, useMediaQuery, } from "@mui/material";
import { addMinutes, differenceInMinutes } from "date-fns";
import { EditorDatePicker } from "../components/inputs/DatePicker";
import { EditorInput } from "../components/inputs/Input";
import { useAppState } from "../hooks/useAppState";
import { EditorSelect } from "../components/inputs/SelectInput";
import { arraytizeFieldVal } from "../helpers/generals";
const initialState = (fields, event) => {
    var _a;
    const customFields = {};
    for (const field of fields) {
        const defVal = arraytizeFieldVal(field, field.default, event);
        const eveVal = arraytizeFieldVal(field, event === null || event === void 0 ? void 0 : event[field.name], event);
        customFields[field.name] = {
            value: eveVal.value || defVal.value || "",
            validity: ((_a = field.config) === null || _a === void 0 ? void 0 : _a.required)
                ? !!eveVal.validity || !!defVal.validity
                : true,
            type: field.type,
            config: field.config,
        };
    }
    return Object.assign({ event_id: {
            value: (event === null || event === void 0 ? void 0 : event.event_id) || null,
            validity: true,
            type: "hidden",
        }, title: {
            value: (event === null || event === void 0 ? void 0 : event.title) || "",
            validity: !!(event === null || event === void 0 ? void 0 : event.title),
            type: "input",
            config: { label: "Title", required: true, min: 3 },
        }, start: {
            value: (event === null || event === void 0 ? void 0 : event.start) || new Date(),
            validity: true,
            type: "date",
            config: { label: "Start", sm: 6 },
        }, end: {
            value: (event === null || event === void 0 ? void 0 : event.end) || new Date(),
            validity: true,
            type: "date",
            config: { label: "End", sm: 6 },
        } }, customFields);
};
const Editor = () => {
    const { fields, dialog, triggerDialog, selectedRange, selectedEvent, triggerLoading, onConfirm, customEditor, confirmEvent, dialogMaxWidth, } = useAppState();
    const [state, setState] = useState(initialState(fields, selectedEvent || selectedRange));
    const [touched, setTouched] = useState(false);
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down("sm"));
    const handleEditorState = (name, value, validity) => {
        setState((prev) => {
            return Object.assign(Object.assign({}, prev), { [name]: Object.assign(Object.assign({}, prev[name]), { value, validity }) });
        });
    };
    const handleClose = (clearState) => {
        if (clearState) {
            setState(initialState(fields));
        }
        triggerDialog(false);
    };
    const handleConfirm = () => __awaiter(void 0, void 0, void 0, function* () {
        let body = {};
        for (const key in state) {
            body[key] = state[key].value;
            if (!customEditor && !state[key].validity) {
                return setTouched(true);
            }
        }
        try {
            triggerLoading(true);
            // Auto fix date
            body.end =
                body.start >= body.end
                    ? addMinutes(body.start, differenceInMinutes(selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.end, selectedRange === null || selectedRange === void 0 ? void 0 : selectedRange.start))
                    : body.end;
            // Specify action
            const action = (selectedEvent === null || selectedEvent === void 0 ? void 0 : selectedEvent.event_id) ? "edit" : "create";
            // Trigger custom/remote when provided
            if (onConfirm) {
                body = yield onConfirm(body, action);
            }
            else {
                // Create/Edit local data
                body.event_id =
                    (selectedEvent === null || selectedEvent === void 0 ? void 0 : selectedEvent.event_id) ||
                        Date.now().toString(36) + Math.random().toString(36).slice(2);
            }
            confirmEvent(body, action);
            handleClose(true);
        }
        catch (error) {
            console.error(error);
        }
        finally {
            triggerLoading(false);
        }
    });
    const renderInputs = (key) => {
        const stateItem = state[key];
        switch (stateItem.type) {
            case "input":
                return (_jsx(EditorInput, Object.assign({ value: stateItem.value, name: key, onChange: handleEditorState, touched: touched }, stateItem.config), void 0));
            case "date":
                return (_jsx(EditorDatePicker, Object.assign({ value: stateItem.value, name: key, onChange: (...args) => handleEditorState(...args, true) }, stateItem.config), void 0));
            case "select":
                const field = fields.find((f) => f.name === key);
                return (_jsx(EditorSelect, Object.assign({ value: stateItem.value, name: key, options: (field === null || field === void 0 ? void 0 : field.options) || [], onChange: handleEditorState, touched: touched }, stateItem.config), void 0));
            default:
                return "";
        }
    };
    const renderEditor = () => {
        if (customEditor) {
            const schedulerHelpers = {
                state,
                close: () => triggerDialog(false),
                loading: (load) => triggerLoading(load),
                edited: selectedEvent,
                onConfirm: confirmEvent,
            };
            return customEditor(schedulerHelpers);
        }
        return (_jsxs(Fragment, { children: [_jsx(DialogTitle, { children: selectedEvent ? "Edit Event" : "Add Event" }, void 0),
                _jsx(DialogContent, Object.assign({ style: { overflowX: "hidden" } }, { children: _jsx(Grid, Object.assign({ container: true, spacing: 1 }, { children: Object.keys(state).map((key) => {
                            var _a;
                            const item = state[key];
                            return (_jsx(Grid, Object.assign({ item: true, sm: (_a = item.config) === null || _a === void 0 ? void 0 : _a.sm, xs: 12 }, { children: renderInputs(key) }), key));
                        }) }), void 0) }), void 0),
                _jsxs(DialogActions, { children: [_jsx(Button, Object.assign({ color: "inherit", fullWidth: true, onClick: () => handleClose() }, { children: "Cancel" }), void 0),
                        _jsx(Button, Object.assign({ color: "primary", fullWidth: true, onClick: handleConfirm }, { children: "Confirm" }), void 0)] }, void 0)] }, void 0));
    };
    return (_jsx(Dialog, Object.assign({ open: dialog, fullScreen: isMobile, maxWidth: dialogMaxWidth }, { children: renderEditor() }), void 0));
};
export default Editor;
