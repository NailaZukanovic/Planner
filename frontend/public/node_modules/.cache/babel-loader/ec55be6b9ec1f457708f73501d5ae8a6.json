{"ast":null,"code":"import { useControllableState as e } from \"@radix-ui/react-use-controllable-state\";\nimport { useCallbackRef as o } from \"@radix-ui/react-use-callback-ref\";\nimport { Primitive as r } from \"@radix-ui/react-primitive\";\nimport { useId as t } from \"@radix-ui/react-id\";\nimport { createContextScope as n } from \"@radix-ui/react-context\";\nimport { useComposedRefs as i } from \"@radix-ui/react-compose-refs\";\nimport { createCollection as c } from \"@radix-ui/react-collection\";\nimport { composeEventHandlers as u } from \"@radix-ui/primitive\";\nimport * as a from \"react\";\nimport s from \"@babel/runtime/helpers/esm/extends\";\nconst f = {\n  bubbles: !1,\n  cancelable: !0\n},\n      [p, l, m] = c(\"RovingFocusGroup\"),\n      [d, v] = n(\"RovingFocusGroup\", [m]);\nexport { v as createRovingFocusGroupScope };\nconst [g, F] = d(\"RovingFocusGroup\");\nexport const RovingFocusGroup = /*#__PURE__*/a.forwardRef((e, o) => /*#__PURE__*/a.createElement(p.Provider, {\n  scope: e.__scopeRovingFocusGroup\n}, /*#__PURE__*/a.createElement(p.Slot, {\n  scope: e.__scopeRovingFocusGroup\n}, /*#__PURE__*/a.createElement(w, s({}, e, {\n  ref: o\n})))));\n/*#__PURE__*/\n\nconst w = /*#__PURE__*/a.forwardRef((t, n) => {\n  const {\n    __scopeRovingFocusGroup: c,\n    orientation: p,\n    dir: m = \"ltr\",\n    loop: d = !1,\n    currentTabStopId: v,\n    defaultCurrentTabStopId: F,\n    onCurrentTabStopIdChange: w,\n    onEntryFocus: b,\n    ...x\n  } = t,\n        E = a.useRef(null),\n        I = i(n, E),\n        [G = null, h] = e({\n    prop: v,\n    defaultProp: F,\n    onChange: w\n  }),\n        [T, A] = a.useState(!1),\n        y = o(b),\n        D = l(c),\n        S = a.useRef(!1);\n  return a.useEffect(() => {\n    const e = E.current;\n    if (e) return e.addEventListener(\"rovingFocusGroup.onEntryFocus\", y), () => e.removeEventListener(\"rovingFocusGroup.onEntryFocus\", y);\n  }, [y]), /*#__PURE__*/a.createElement(g, {\n    scope: c,\n    orientation: p,\n    dir: m,\n    loop: d,\n    currentTabStopId: G,\n    onItemFocus: a.useCallback(e => h(e), [h]),\n    onItemShiftTab: a.useCallback(() => A(!0), [])\n  }, /*#__PURE__*/a.createElement(r.div, s({\n    tabIndex: T ? -1 : 0,\n    \"aria-orientation\": p,\n    \"data-orientation\": p\n  }, x, {\n    ref: I,\n    style: {\n      outline: \"none\",\n      ...t.style\n    },\n    onMouseDown: u(t.onMouseDown, () => {\n      S.current = !0;\n    }),\n    onFocus: u(t.onFocus, e => {\n      const o = !S.current;\n\n      if (e.target === e.currentTarget && o && !T) {\n        const o = new Event(\"rovingFocusGroup.onEntryFocus\", f);\n\n        if (e.currentTarget.dispatchEvent(o), !o.defaultPrevented) {\n          const e = D().filter(e => e.focusable);\n          R([e.find(e => e.active), e.find(e => e.id === G), ...e].filter(Boolean).map(e => e.ref.current));\n        }\n      }\n\n      S.current = !1;\n    }),\n    onBlur: u(t.onBlur, () => A(!1))\n  })));\n});\nexport const RovingFocusGroupItem = /*#__PURE__*/a.forwardRef((e, o) => {\n  const {\n    __scopeRovingFocusGroup: n,\n    focusable: i = !0,\n    active: c = !1,\n    ...f\n  } = e,\n        m = t(),\n        d = F(\"RovingFocusGroupItem\", n),\n        v = d.currentTabStopId === m,\n        g = l(n);\n  /*#__PURE__*/\n\n  return a.createElement(p.ItemSlot, {\n    scope: n,\n    id: m,\n    focusable: i,\n    active: c\n  }, /*#__PURE__*/a.createElement(r.span, s({\n    tabIndex: v ? 0 : -1,\n    \"data-orientation\": d.orientation\n  }, f, {\n    ref: o,\n    onMouseDown: u(e.onMouseDown, e => {\n      i ? d.onItemFocus(m) : e.preventDefault();\n    }),\n    onFocus: u(e.onFocus, () => d.onItemFocus(m)),\n    onKeyDown: u(e.onKeyDown, e => {\n      if (\"Tab\" === e.key && e.shiftKey) return void d.onItemShiftTab();\n      if (e.target !== e.currentTarget) return;\n\n      const o = function (e, o, r) {\n        const t = function (e, o) {\n          return \"rtl\" !== o ? e : \"ArrowLeft\" === e ? \"ArrowRight\" : \"ArrowRight\" === e ? \"ArrowLeft\" : e;\n        }(e.key, r);\n\n        return \"vertical\" === o && [\"ArrowLeft\", \"ArrowRight\"].includes(t) || \"horizontal\" === o && [\"ArrowUp\", \"ArrowDown\"].includes(t) ? void 0 : b[t];\n      }(e, d.orientation, d.dir);\n\n      if (void 0 !== o) {\n        e.preventDefault();\n        let n = g().filter(e => e.focusable).map(e => e.ref.current);\n        if (\"last\" === o) n.reverse();else if (\"prev\" === o || \"next\" === o) {\n          \"prev\" === o && n.reverse();\n          const i = n.indexOf(e.currentTarget);\n          n = d.loop ? (t = i + 1, (r = n).map((e, o) => r[(t + o) % r.length])) : n.slice(i + 1);\n        }\n        setTimeout(() => R(n));\n      }\n\n      var r, t;\n    })\n  })));\n});\n/*#__PURE__*/\n\nconst b = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\n\nfunction R(e) {\n  const o = document.activeElement;\n\n  for (const r of e) {\n    if (r === o) return;\n    if (r.focus(), document.activeElement !== o) return;\n  }\n}\n\nexport const Root = RovingFocusGroup;\nexport const Item = RovingFocusGroupItem;","map":{"version":3,"sources":["packages/react/roving-focus/src/RovingFocusGroup.tsx"],"names":["EVENT_OPTIONS","bubbles","cancelable","Collection","useCollection","createCollectionScope","createCollection","createRovingFocusGroupContext","createRovingFocusGroupScope","createContextScope","RovingFocusProvider","useRovingFocusContext","RovingFocusGroup","React","forwardRef","props","forwardedRef","_react","$aa7392b6d04813384a511e60e09$var$Collection","Provider","scope","__scopeRovingFocusGroup","Slot","$aa7392b6d04813384a511e60e09$var$RovingFocusGroupImpl","ref","RovingFocusGroupImpl","orientation","dir","loop","currentTabStopId","currentTabStopIdProp","defaultCurrentTabStopId","onCurrentTabStopIdChange","onEntryFocus","groupProps","useRef","composedRefs","useComposedRefs","setCurrentTabStopId","useControllableState","prop","defaultProp","onChange","isTabbingBackOut","setIsTabbingBackOut","useState","handleEntryFocus","useCallbackRef","getItems","isClickFocusRef","useEffect","node","current","addEventListener","removeEventListener","$aa7392b6d04813384a511e60e09$var$RovingFocusProvider","onItemFocus","useCallback","tabStopId","onItemShiftTab","Primitive","div","tabIndex","style","outline","onMouseDown","composeEventHandlers","onFocus","event","isKeyboardFocus","target","currentTarget","entryFocusEvent","Event","dispatchEvent","defaultPrevented","items","filter","item","focusable","find","active","id","Boolean","map","focusFirst","onBlur","RovingFocusGroupItem","itemProps","useId","context","isCurrentTabStop","ItemSlot","span","preventDefault","onKeyDown","key","shiftKey","focusIntent","getFocusIntent","undefined","candidateNodes","reverse","currentIndex","indexOf","slice","setTimeout","MAP_KEY_TO_FOCUS_INTENT","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","PageUp","Home","PageDown","End","getDirectionAwareKey","includes","candidates","PREVIOUSLY_FOCUSED_ELEMENT","document","activeElement","candidate","focus","array","startIndex","_","index","length","Root","Item"],"mappings":";;;;;;;;;;AAaA,MACMA,CAAAA,GAAgB;AAAEC,EAAAA,OAAAA,EAAAA,CAAS,CAAX;AAAkBC,EAAAA,UAAAA,EAAAA,CAAY;AAA9B,CADtB;AAAA,MACoD,CAS7CC,CAT6C,EASjCC,CATiC,EASlBC,CATkB,IASOC,CAAAA,CAHxC,kBAGwCA,CAV3D;AAAA,MAOmB,CASZC,CATY,EASmBC,CATnB,IASkDC,CAAAA,CATlD,kBASkDA,EAEnE,CAACJ,CAAD,CAFmEI,CAhBrE;AAkBGJ,SAAAA,CAAAA,IAAAA,2BAAAA;AA8BH,MAAA,CAAOK,CAAP,EAA4BC,CAA5B,IACEJ,CAAAA,CA1CiB,kBA0CjBA,CADF;AAzCmB,OA+CnB,MAAMK,gBAAAA,GAAAA,aAAmBC,CAAAA,CAAMC,UAAND,CACvB,CAACE,CAAD,EAA4CC,CAA5C,KAA4CA,aAExCC,CAAAA,CAAAA,aAAAA,CAACC,CAAAA,CAAWC,QAAZF,EAAAA;AAAqBG,EAAAA,KAAAA,EAAOL,CAAAA,CAAMM;AAAlCJ,CAAAA,EAAkCI,aAChCJ,CAAAA,CAAAA,aAAAA,CAACC,CAAAA,CAAWI,IAAZL,EAAAA;AAAiBG,EAAAA,KAAAA,EAAOL,CAAAA,CAAMM;AAA9BJ,CAAAA,EAA8BI,aAC5BJ,CAAAA,CAAAA,aAAAA,CAACM,CAADN,EAAAA,CAAAA,CAAAA,EAAAA,EAA0BF,CAA1BE,EAAAA;AAAiCO,EAAAA,GAAAA,EAAKR;AAAtCC,CAAAA,CAAAA,CADFA,CADFA,CAHmBJ,CAAzB;AAKgDG;;AAsBhD,MAAMS,CAAAA,GAAAA,aAAuBZ,CAAAA,CAAMC,UAAND,CAG3B,CAACE,CAAD,EAAgDC,CAAhD,KAAgDA;AAChD,QAAA;AAAMK,IAAAA,uBAAAA,EACJA,CADF;AAAMA,IAAAA,WAAAA,EAEJK,CAFF;AAAML,IAAAA,GAAAA,EAGJM,CAAAA,GAAM,KAHR;AAAMN,IAAAA,IAAAA,EAIJO,CAAAA,GAAAA,CAAO,CAJT;AAKEC,IAAAA,gBAAAA,EAAkBC,CALpB;AAAMT,IAAAA,uBAAAA,EAMJU,CANF;AAAMV,IAAAA,wBAAAA,EAOJW,CAPF;AAAMX,IAAAA,YAAAA,EAQJY,CARF;AAQEA,OACGC;AATL,MAUInB,CAVJ;AAAA,QAWMS,CAAAA,GAAMX,CAAAA,CAAMsB,MAANtB,CAA0C,IAA1CA,CAXZ;AAAA,QAYMuB,CAAAA,GAAeC,CAAAA,CAAgBrB,CAAhBqB,EAA8Bb,CAA9Ba,CAZrB;AAAA,QAYmDb,CAC5CK,CAAAA,GAAmB,IADyBL,EACnBc,CADmBd,IACIe,CAAAA,CAAqB;AAC1EC,IAAAA,IAAAA,EAAMV,CADoE;AAE1EW,IAAAA,WAAAA,EAAaV,CAF6D;AAG1EW,IAAAA,QAAAA,EAAUV;AAHgE,GAArBO,CAbvD;AAAA,QAgBYP,CAELW,CAFKX,EAEaY,CAFbZ,IAEoCnB,CAAAA,CAAMgC,QAANhC,CAAMgC,CAAS,CAAfhC,CAlBhD;AAAA,QAmBMiC,CAAAA,GAAmBC,CAAAA,CAAed,CAAfc,CAnBzB;AAAA,QAoBMC,CAAAA,GAAW5C,CAAAA,CAAciB,CAAdjB,CApBjB;AAAA,QAqBM6C,CAAAA,GAAkBpC,CAAAA,CAAMsB,MAANtB,CAAMsB,CAAO,CAAbtB,CArBxB;AA+BA,SARAA,CAAAA,CAAMqC,SAANrC,CAAgB,MAAA;AACd,UAAMsC,CAAAA,GAAO3B,CAAAA,CAAI4B,OAAjB;AACA,QAAID,CAAJ,EAEE,OADAA,CAAAA,CAAKE,gBAALF,CA/Gc,+BA+GdA,EAAmCL,CAAnCK,GACO,MAAMA,CAAAA,CAAKG,mBAALH,CAhHC,+BAgHDA,EAAsCL,CAAtCK,CAAb;AAAmDL,GAJvDjC,EAMG,CAACiC,CAAD,CANHjC,GAMIiC,aAGF7B,CAAAA,CAAAA,aAAAA,CAACsC,CAADtC,EAAAA;AACEG,IAAAA,KAAAA,EAAOC,CADTJ;AAEES,IAAAA,WAAAA,EAAaA,CAFfT;AAGEU,IAAAA,GAAAA,EAAKA,CAHPV;AAIEW,IAAAA,IAAAA,EAAMA,CAJRX;AAKEY,IAAAA,gBAAAA,EAAkBA,CALpBZ;AAMEuC,IAAAA,WAAAA,EAAa3C,CAAAA,CAAM4C,WAAN5C,CACV6C,CAAAA,IAAcpB,CAAAA,CAAoBoB,CAApBpB,CADJzB,EAEX,CAACyB,CAAD,CAFWzB,CANfI;AAUE0C,IAAAA,cAAAA,EAAgB9C,CAAAA,CAAM4C,WAAN5C,CAAkB,MAAM+B,CAAAA,CAAAA,CAAoB,CAApBA,CAAxB/B,EAAmD,EAAnDA;AAVlBI,GAAAA,EAUqE,aAEnEA,CAAAA,CAAAA,aAAAA,CAAC2C,CAAAA,CAAUC,GAAX5C,EAAAA,CAAAA,CAAAA;AACE6C,IAAAA,QAAAA,EAAUnB,CAAAA,GAAAA,CAAoB,CAApBA,GAAwB,CADpC1B;AAEE,wBAAkBS,CAFpBT;AAGE,wBAAkBS;AAHpBT,GAAAA,EAIMiB,CAJNjB,EAAAA;AAKEO,IAAAA,GAAAA,EAAKY,CALPnB;AAME8C,IAAAA,KAAAA,EAAO;AAAEC,MAAAA,OAAAA,EAAS,MAAX;AAAW,SAAWjD,CAAAA,CAAMgD;AAA5B,KANT9C;AAOEgD,IAAAA,WAAAA,EAAaC,CAAAA,CAAqBnD,CAAAA,CAAMkD,WAA3BC,EAAwC,MAAA;AACnDjB,MAAAA,CAAAA,CAAgBG,OAAhBH,GAAgBG,CAAU,CAA1BH;AAA0B,KADfiB,CAPfjD;AAUEkD,IAAAA,OAAAA,EAASD,CAAAA,CAAqBnD,CAAAA,CAAMoD,OAA3BD,EAAqCE,CAAAA,IAAAA;AAK5C,YAAMC,CAAAA,GAAAA,CAAmBpB,CAAAA,CAAgBG,OAAzC;;AAEA,UAAIgB,CAAAA,CAAME,MAANF,KAAiBA,CAAAA,CAAMG,aAAvBH,IAAwCC,CAAxCD,IAAwCC,CAAoB1B,CAAhE,EAAkF;AAChF,cAAM6B,CAAAA,GAAkB,IAAIC,KAAJ,CAnJhB,+BAmJgB,EAAuBzE,CAAvB,CAAxB;;AAGA,YAFAoE,CAAAA,CAAMG,aAANH,CAAoBM,aAApBN,CAAkCI,CAAlCJ,GAAkCI,CAE7BA,CAAAA,CAAgBG,gBAArB,EAAuC;AACrC,gBAAMC,CAAAA,GAAQ5B,CAAAA,GAAW6B,MAAX7B,CAAmB8B,CAAAA,IAASA,CAAAA,CAAKC,SAAjC/B,CAAd;AAOAqC,UAAAA,CAAAA,CAJuB,CAFJT,CAAAA,CAAMI,IAANJ,CAAYE,CAAAA,IAASA,CAAAA,CAAKG,MAA1BL,CAEI,EADHA,CAAAA,CAAMI,IAANJ,CAAYE,CAAAA,IAASA,CAAAA,CAAKI,EAALJ,KAAYjD,CAAjC+C,CACG,EAD8B/C,GACD+C,CAA7B,EAAoCC,MAApC,CACrBM,OADqB,EAGeC,GAHf,CAGoBN,CAAAA,IAASA,CAAAA,CAAKtD,GAALsD,CAAS1B,OAHtC,CAIvBiC,CAAAA;AAD6DjC;AAKjEH;;AAAAA,MAAAA,CAAAA,CAAgBG,OAAhBH,GAAgBG,CAAU,CAA1BH;AAA0B,KAvBnBiB,CAVXjD;AAmCEqE,IAAAA,MAAAA,EAAQpB,CAAAA,CAAqBnD,CAAAA,CAAMuE,MAA3BpB,EAAmC,MAAMtB,CAAAA,CAAAA,CAAoB,CAApBA,CAAzCsB;AAnCVjD,GAAAA,CAAAA,CAZFA,CADF;AAgD2E,CAnFhDJ,CAA7B;AAmF6E,OAmB7E,MAAM0E,oBAAAA,GAAAA,aAAuB1E,CAAAA,CAAMC,UAAND,CAC3B,CAACE,CAAD,EAA2CC,CAA3C,KAA2CA;AACzC,QAAA;AAAMK,IAAAA,uBAAAA,EAAEA,CAAR;AAAMA,IAAAA,SAAAA,EAA2B0D,CAAAA,GAAAA,CAAY,CAA7C;AAAM1D,IAAAA,MAAAA,EAA6C4D,CAAAA,GAAAA,CAAS,CAA5D;AAA4D,OAAUO;AAAtE,MAAoFzE,CAApF;AAAA,QACMmE,CAAAA,GAAKO,CAAAA,EADX;AAAA,QAEMC,CAAAA,GAAU/E,CAAAA,CAbF,sBAaEA,EAAiCU,CAAjCV,CAFhB;AAAA,QAGMgF,CAAAA,GAAmBD,CAAAA,CAAQ7D,gBAAR6D,KAA6BR,CAHtD;AAAA,QAIMlC,CAAAA,GAAW5C,CAAAA,CAAciB,CAAdjB,CAJjB;AAI+BiB;;AAE/B,SACEJ,CAAAA,CAAAA,aAAAA,CAACC,CAAAA,CAAW0E,QAAZ3E,EAAAA;AACEG,IAAAA,KAAAA,EAAOC,CADTJ;AAEEiE,IAAAA,EAAAA,EAAIA,CAFNjE;AAGE8D,IAAAA,SAAAA,EAAWA,CAHb9D;AAIEgE,IAAAA,MAAAA,EAAQA;AAJVhE,GAAAA,EAIUgE,aAERhE,CAAAA,CAAAA,aAAAA,CAAC2C,CAAAA,CAAUiC,IAAX5E,EAAAA,CAAAA,CAAAA;AACE6C,IAAAA,QAAAA,EAAU6B,CAAAA,GAAmB,CAAnBA,GAAmB,CAAK,CADpC1E;AAEE,wBAAkByE,CAAAA,CAAQhE;AAF5BT,GAAAA,EAGMuE,CAHNvE,EAAAA;AAIEO,IAAAA,GAAAA,EAAKR,CAJPC;AAKEgD,IAAAA,WAAAA,EAAaC,CAAAA,CAAqBnD,CAAAA,CAAMkD,WAA3BC,EAAyCE,CAAAA,IAAAA;AAG/CW,MAAAA,CAAAA,GAEAW,CAAAA,CAAQlC,WAARkC,CAAoBR,CAApBQ,CAFAX,GAAWX,CAAAA,CAAM0B,cAAN1B,EAAXW;AAAiBe,KAHX5B,CALfjD;AAYEkD,IAAAA,OAAAA,EAASD,CAAAA,CAAqBnD,CAAAA,CAAMoD,OAA3BD,EAAoC,MAAMwB,CAAAA,CAAQlC,WAARkC,CAAoBR,CAApBQ,CAA1CxB,CAZXjD;AAaE8E,IAAAA,SAAAA,EAAW7B,CAAAA,CAAqBnD,CAAAA,CAAMgF,SAA3B7B,EAAuCE,CAAAA,IAAAA;AAChD,UAAkB,UAAdA,CAAAA,CAAM4B,GAAQ,IAAS5B,CAAAA,CAAM6B,QAAjC,EAEE,OAAA,KADAP,CAAAA,CAAQ/B,cAAR+B,EACA;AAGF,UAAItB,CAAAA,CAAME,MAANF,KAAiBA,CAAAA,CAAMG,aAA3B,EAA0C;;AAE1C,YAAM2B,CAAAA,GAgDlB,UAAwB9B,CAAxB,EAAoD1C,CAApD,EAA+EC,CAA/E,EAA+EA;AAC7E,cAAMqE,CAAAA,GARR,UAA8BA,CAA9B,EAA2CrE,CAA3C,EAA2CA;AACzC,iBAAY,UAARA,CAAQ,GAAcqE,CAAd,GACG,gBAARA,CAAQ,GAAc,YAAd,GAAqC,iBAARA,CAAQ,GAAe,WAAf,GAA6BA,CADjF;AAOYoB,SARd,CAQmChD,CAAAA,CAAM4B,GARzC,EAQ8CrE,CAR9C,CAQE;;AACA,eAAoB,eAAhBD,CAAgB,IAAc,CAAC,WAAD,EAAc,YAAd,EAA4B2F,QAA5B,CAAqCrB,CAArC,CAAd,IACA,iBAAhBtE,CAAgB,IAAgB,CAAC,SAAD,EAAY,WAAZ,EAAyB2F,QAAzB,CAAkCrB,CAAlC,CADhB,GACkDA,KADO,CAAzD,GAEbW,CAAAA,CAAwBX,CAAxBW,CAFP;AAlD8BR,OAgDhC,CAhD+C/B,CAgD/C,EAhDsDsB,CAAAA,CAAQhE,WAgD9D,EAhD2EgE,CAAAA,CAAQ/D,GAgDnF,CAhDY;;AAEA,UAAA,KAAoByE,CAApB,KAAIF,CAAJ,EAA+B;AAC7B9B,QAAAA,CAAAA,CAAM0B,cAAN1B;AAEA,YAAIiC,CAAAA,GADUrD,CAAAA,GAAW6B,MAAX7B,CAAmB8B,CAAAA,IAASA,CAAAA,CAAKC,SAAjC/B,EACaoC,GADbpC,CACkB8B,CAAAA,IAASA,CAAAA,CAAKtD,GAALsD,CAAS1B,OADpCJ,CACd;AAEA,YAAoB,WAAhBkD,CAAJ,EAA4BG,CAAAA,CAAeC,OAAfD,GAA5B,KACK,IAAoB,WAAhBH,CAAgB,IAA0B,WAAhBA,CAA9B,EAAsD;AACrC,qBAAhBA,CAAgB,IAAQG,CAAAA,CAAeC,OAAfD,EAAR;AACpB,gBAAME,CAAAA,GAAeF,CAAAA,CAAeG,OAAfH,CAAuBjC,CAAAA,CAAMG,aAA7B8B,CAArB;AACAA,UAAAA,CAAAA,GAAiBX,CAAAA,CAAQ9D,IAAR8D,IA0DCmC,CAAAA,GAzDYtB,CAAAA,GAAe,CAyD3BsB,EAzD2B,CAyDvCD,CAAAA,GAzDQvB,CAA+B,EA0D9CjB,GA1D8C,CA0D1C,CAAC0C,CAAD,EAAIC,CAAJ,KAAcH,CAAAA,CAAAA,CAAOC,CAAAA,GAAaE,CAApBH,IAA6BA,CAAAA,CAAMI,MAAnCJ,CA1D4B,CAD5BlC,IAEbW,CAAAA,CAAeI,KAAfJ,CAAqBE,CAAAA,GAAe,CAApCF,CAFJA;AASFK;AAAAA,QAAAA,UAAAA,CAAW,MAAMrB,CAAAA,CAAWgB,CAAXhB,CAAjBqB,CAAAA;AAiDd;;AAAA,UAAsBkB,CAAtB,EAAkCC,CAAlC;AAAkCA,KA7Eb3D;AAbbjD,GAAAA,CAAAA,CANFA,CADF;AAiG8B4G,CAzGLhH,CAA7B;AAyGkCgH;;AAnClC,MAAMlB,CAAAA,GAAuD;AAC3DC,EAAAA,SAAAA,EAAW,MADgD;AACxCC,EAAAA,OAAAA,EAAS,MAD+B;AAE3DC,EAAAA,UAAAA,EAAY,MAF+C;AAEvCC,EAAAA,SAAAA,EAAW,MAF4B;AAG3DC,EAAAA,MAAAA,EAAQ,OAHmD;AAG1CC,EAAAA,IAAAA,EAAM,OAHoC;AAI3DC,EAAAA,QAAAA,EAAU,MAJiD;AAIzCC,EAAAA,GAAAA,EAAK;AAJoC,CAA7D;;AAqBA,SAAS9B,CAAT,CAAoBiC,CAApB,EAAoBA;AAClB,QAAMC,CAAAA,GAA6BC,QAAAA,CAASC,aAA5C;;AACA,OAAK,MAAMC,CAAX,IAAwBJ,CAAxB,EAAoC;AAElC,QAAII,CAAAA,KAAcH,CAAlB,EAA8C;AAE9C,QADAG,CAAAA,CAAUC,KAAVD,IACIF,QAAAA,CAASC,aAATD,KAA2BD,CAA/B,EAA2D;AAAA;AAAA;;AAAA,OAY/D,MAAMU,IAAAA,GAAOrH,gBAAb;AAAaA,OACb,MAAMsH,IAAAA,GAAO3C,oBAAb","sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   * @defaultValue ltr\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    dir = 'ltr',\n    loop = false,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={dir}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut ? -1 : 0}\n        aria-orientation={orientation}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new Event(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends PrimitiveSpanProps {\n  focusable?: boolean;\n  active?: boolean;\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const { __scopeRovingFocusGroup, focusable = true, active = false, ...itemProps } = props;\n    const id = useId();\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        />\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n"]},"metadata":{},"sourceType":"module"}