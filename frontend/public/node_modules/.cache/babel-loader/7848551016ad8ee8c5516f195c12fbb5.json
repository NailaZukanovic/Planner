{"ast":null,"code":"var _excluded = [\"children\", \"errors\", \"infos\", \"messages\", \"onChange\", \"onReset\", \"onSubmit\", \"onValidate\", \"validate\", \"value\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport React, { forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { FormContext } from './FormContext';\nimport { FormPropTypes } from './propTypes';\nvar defaultValue = {};\nvar defaultTouched = {};\nvar defaultValidationResults = {\n  errors: {},\n  infos: {}\n};\n\nvar stringToArray = function stringToArray(string) {\n  var match = string == null ? void 0 : string.match(/^(.+)\\[([0-9]+)\\]\\.(.*)$/);\n\n  if (match) {\n    var arrayName = match[1],\n        indexOfArray = match[2],\n        arrayObjName = match[3];\n    return {\n      indexOfArray: indexOfArray,\n      arrayName: arrayName,\n      arrayObjName: arrayObjName\n    };\n  }\n\n  return undefined;\n};\n\nvar getFieldValue = function getFieldValue(name, value) {\n  var isArrayField = stringToArray(name);\n\n  if (isArrayField) {\n    var _value$arrayName;\n\n    var indexOfArray = isArrayField.indexOfArray,\n        arrayName = isArrayField.arrayName,\n        arrayObjName = isArrayField.arrayObjName;\n    var obj = (_value$arrayName = value[arrayName]) == null ? void 0 : _value$arrayName[indexOfArray];\n    return arrayObjName ? obj == null ? void 0 : obj[arrayObjName] : obj;\n  }\n\n  return value[name];\n};\n\nvar setFieldValue = function setFieldValue(name, componentValue, prevValue) {\n  var nextValue = _extends({}, prevValue);\n\n  var isArrayField = stringToArray(name);\n\n  if (isArrayField) {\n    var indexOfArray = isArrayField.indexOfArray,\n        arrayName = isArrayField.arrayName,\n        arrayObjName = isArrayField.arrayObjName;\n    if (!nextValue[arrayName]) nextValue[arrayName] = [];\n\n    if (arrayObjName) {\n      var _nextValue$arrayName$;\n\n      if (!nextValue[arrayName][indexOfArray]) nextValue[arrayName][indexOfArray] = (_nextValue$arrayName$ = {}, _nextValue$arrayName$[arrayObjName] = componentValue, _nextValue$arrayName$);\n      nextValue[arrayName][indexOfArray][arrayObjName] = componentValue;\n    } else nextValue[arrayName][indexOfArray] = componentValue;\n  } else {\n    nextValue[name] = componentValue;\n  }\n\n  return nextValue;\n}; // Apply validation rule to field value and send correct messaging.\n\n\nvar validate = function validate(rule, fieldValue, formValue, format, messages) {\n  var result;\n\n  if (typeof rule === 'function') {\n    result = rule(fieldValue, formValue);\n  } else if (rule.regexp) {\n    if (!rule.regexp.test(fieldValue)) {\n      result = rule.message || format({\n        id: 'form.invalid',\n        messages: messages\n      });\n\n      if (rule.status) {\n        result = {\n          message: result,\n          status: rule.status\n        };\n      }\n    }\n  }\n\n  return result;\n}; // Validates particular key in formValue\n\n\nvar validateName = function validateName(validationRules, required) {\n  return function (name, formValue, format, messages) {\n    var fieldValue = getFieldValue(name, formValue);\n    var validationResult; // ValidateArg is something that gets passed in from a FormField component\n    // See 'validate' prop in FormField\n\n    if (required && ( // false is for CheckBox\n    fieldValue === undefined || fieldValue === '' || fieldValue === false || Array.isArray(fieldValue) && !fieldValue.length)) {\n      // There is no value at that name, and one is required\n      validationResult = format({\n        id: 'form.required',\n        messages: messages\n      });\n    } else if (validationRules) {\n      if (Array.isArray(validationRules)) {\n        validationRules.some(function (validator) {\n          validationResult = validate(validator, fieldValue, formValue, format, messages);\n          return !!validationResult;\n        });\n      } else {\n        validationResult = validate(validationRules, fieldValue, formValue, format, messages);\n      }\n    }\n\n    return validationResult;\n  };\n}; // validations is an array from Object.entries()\n// Validates all keys in formValue\n\n\nvar validateForm = function validateForm(validationRules, formValue, format, messages, omitValid) {\n  var nextErrors = {};\n  var nextInfos = {};\n  validationRules.forEach(function (_ref) {\n    var name = _ref[0],\n        _ref$ = _ref[1],\n        field = _ref$.field,\n        input = _ref$.input;\n\n    if (!omitValid) {\n      nextErrors[name] = undefined;\n      nextInfos[name] = undefined;\n    }\n\n    var result;\n\n    if (input) {\n      // input() a validation function supplied through useFormInput()\n      result = input(name, formValue, format, messages);\n    }\n\n    if (field && !result) {\n      // field() a validation function supplied through useFormField()\n      result = field(name, formValue, format, messages);\n    } // typeof error === 'object' is implied for both cases of error with\n    // a status message and for an error object that is a react node\n\n\n    if (typeof result === 'object') {\n      if (result.status === 'info') {\n        nextInfos[name] = result.message;\n      } else {\n        nextErrors[name] = result.message || result; // could be a node\n      }\n    } else if (typeof result === 'string') {\n      nextErrors[name] = result;\n    }\n  });\n  return [nextErrors, nextInfos];\n};\n\nvar Form = /*#__PURE__*/forwardRef(function (_ref2, ref) {\n  var children = _ref2.children,\n      _ref2$errors = _ref2.errors,\n      errorsProp = _ref2$errors === void 0 ? defaultValidationResults.errors : _ref2$errors,\n      _ref2$infos = _ref2.infos,\n      infosProp = _ref2$infos === void 0 ? defaultValidationResults.infos : _ref2$infos,\n      messages = _ref2.messages,\n      onChange = _ref2.onChange,\n      _onReset = _ref2.onReset,\n      _onSubmit = _ref2.onSubmit,\n      onValidate = _ref2.onValidate,\n      _ref2$validate = _ref2.validate,\n      validateOn = _ref2$validate === void 0 ? 'submit' : _ref2$validate,\n      valueProp = _ref2.value,\n      rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n  var _useContext = useContext(MessageContext),\n      format = _useContext.format;\n\n  var _useState = useState(valueProp || defaultValue),\n      valueState = _useState[0],\n      setValueState = _useState[1];\n\n  var value = useMemo(function () {\n    return valueProp || valueState;\n  }, [valueProp, valueState]);\n\n  var _useState2 = useState(defaultTouched),\n      touched = _useState2[0],\n      setTouched = _useState2[1];\n\n  var _useState3 = useState(defaultValidationResults),\n      validationResults = _useState3[0],\n      setValidationResults = _useState3[1]; // when onBlur input validation is triggered, we need to complete any\n  // potential click events before running the onBlur validation.\n  // otherwise, click events like reset, etc. may not be registered.\n  // for a detailed scenario/discussion,\n  // see: https://github.com/grommet/grommet/issues/4863\n  // the value of pendingValidation is the name of the FormField\n  // awaiting validation.\n\n\n  var _useState4 = useState(undefined),\n      pendingValidation = _useState4[0],\n      setPendingValidation = _useState4[1];\n\n  useEffect(function () {\n    setPendingValidation(undefined);\n    setValidationResults({\n      errors: errorsProp,\n      infos: infosProp\n    });\n  }, [errorsProp, infosProp]);\n  var validationRulesRef = useRef({});\n  var requiredFields = useRef([]);\n  var buildValid = useCallback(function (nextErrors) {\n    var valid = false;\n    valid = requiredFields.current.filter(function (n) {\n      return Object.keys(validationRulesRef.current).includes(n);\n    }).every(function (field) {\n      return value[field] && (value[field] !== '' || value[field] !== false);\n    });\n    if (Object.keys(nextErrors).length > 0) valid = false;\n    return valid;\n  }, [value]); // Only keep validation results for current form fields. In the case of a\n  // dynamic form, a field possessing an error may have been removed from the\n  // form; need to clean up any previous related validation results.\n\n  var filterRemovedFields = function filterRemovedFields(prevValidations) {\n    var nextValidations = prevValidations;\n    return Object.keys(nextValidations).filter(function (n) {\n      return !validationRulesRef.current[n] || nextValidations[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextValidations[n];\n    });\n  }; // On initial mount, when validateOn is change or blur,\n  // set validation results for any set fields and calculate whether\n  // the form is valid overall.\n\n\n  useEffect(function () {\n    var validationsForSetFields = Object.entries(validationRulesRef.current).filter(function (_ref3) {\n      var n = _ref3[0];\n      return getFieldValue(n, value);\n    });\n\n    if (validationsForSetFields.length > 0 && validateOn !== 'submit') {\n      var _validateForm = validateForm(validationsForSetFields, value, format, messages),\n          errors = _validateForm[0],\n          infos = _validateForm[1];\n\n      filterRemovedFields(errors);\n      filterRemovedFields(infos);\n      var nextValidationResults = {\n        errors: errors,\n        infos: infos,\n        valid: buildValid(errors)\n      };\n      if (onValidate) onValidate(nextValidationResults);\n      setValidationResults(nextValidationResults);\n    } // We only want to run this for the value we have on initial mount.\n    // We don't want subsequent changes to the value to re-run this.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []); // Currently, onBlur validation will trigger after a timeout of 120ms.\n\n  useEffect(function () {\n    var timer = setTimeout(function () {\n      if (pendingValidation) {\n        // run validations on the pending one and any other touched fields\n        var _validateForm2 = validateForm(Object.entries(validationRulesRef.current).filter(function (_ref4) {\n          var n = _ref4[0];\n          return touched[n] || pendingValidation.includes(n);\n        }), value, format, messages),\n            validatedErrors = _validateForm2[0],\n            validatedInfos = _validateForm2[1];\n\n        setPendingValidation(undefined);\n        setValidationResults(function (prevValidationResults) {\n          // keep any previous errors and infos for untouched keys,\n          // these may have come from a submit\n          var nextErrors = _extends({}, prevValidationResults.errors, validatedErrors);\n\n          var nextInfos = _extends({}, prevValidationResults.infos, validatedInfos);\n\n          filterRemovedFields(nextErrors);\n          filterRemovedFields(nextInfos);\n          var nextValidationResults = {\n            errors: nextErrors,\n            infos: nextInfos,\n            valid: buildValid(nextErrors)\n          };\n          if (onValidate) onValidate(nextValidationResults);\n          return nextValidationResults;\n        });\n      } // a timeout is needed to ensure that a click event (like one on a reset\n      // button) completes prior to running the validation. without a timeout,\n      // the blur will always complete and trigger a validation prematurely\n      // The following values have been empirically tested, but 120 was\n      // selected because it is the largest value\n      // Chrome: 100, Safari: 120, Firefox: 80\n\n    }, 120);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [buildValid, format, messages, pendingValidation, onValidate, touched, value, requiredFields]); // clear any errors when value changes\n\n  useEffect(function () {\n    if (validateOn !== 'change') setPendingValidation(undefined);\n    setValidationResults(function (prevValidationResults) {\n      var _validateForm3 = validateForm(Object.entries(validationRulesRef.current).filter(function (_ref5) {\n        var n = _ref5[0];\n        return prevValidationResults.errors[n] || prevValidationResults.infos[n];\n      }), value, format, messages),\n          nextErrors = _validateForm3[0],\n          nextInfos = _validateForm3[1];\n\n      return {\n        errors: _extends({}, prevValidationResults.errors, nextErrors),\n        infos: _extends({}, prevValidationResults.infos, nextInfos)\n      };\n    });\n  }, [format, messages, touched, validateOn, value]); // There are three basic patterns of handling form input value state:\n  //\n  // 1 - form controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the Form component to supply the values used by the input fields.\n  // In useFormContext(), componentValue would be undefined and formValue\n  // is be set to whatever the form state has. Whenever the form state\n  // changes, we update the contextValue so the input component will use\n  // that. When the input component changes, we will call update() to\n  // update the form state.\n  //\n  // 2 - input controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the input components, like TextInput, to supply the value for it.\n  // In useFormContext(), componentValue is this value and we ensure to\n  // update the form state, via update(), and set the contextValue from\n  // the componentValue. When the input component changes, we will\n  // call update() to update the form state.\n  //\n  // 3 - uncontrolled\n  //\n  // In this model, the caller doesn't set a `value` or `onChange` property\n  // at either the form or input component levels.\n  // In useFormContext(), componentValue is undefined and valueProp is\n  // undefined and nothing much happens here. That is, unless the\n  // calling component needs to know the state in order to work, such\n  // as CheckBox or Select. In this case, those components supply\n  // an initialValue, which will trigger updating the contextValue so\n  // they can have access to it.\n  //\n\n  var formContextValue = useMemo(function () {\n    var useFormInput = function useFormInput(_ref6) {\n      var name = _ref6.name,\n          componentValue = _ref6.value,\n          initialValue = _ref6.initialValue,\n          validateArg = _ref6.validate;\n\n      var _useState5 = useState(initialValue),\n          inputValue = _useState5[0],\n          setInputValue = _useState5[1];\n\n      var formValue = name ? getFieldValue(name, value) : undefined; // for dynamic forms, we need to track when an input has been added to\n      // the form value. if the input is unmounted, we will delete its\n      // key/value from the form value.\n\n      var keyCreated = useRef(false); // This effect is for pattern #2, where the controlled input\n      // component is driving the value via componentValue.\n\n      useEffect(function () {\n        if (name && // we have somewhere to put this\n        componentValue !== undefined && // input driving\n        componentValue !== formValue // don't already have it\n        ) {\n          setValueState(function (prevValue) {\n            return setFieldValue(name, componentValue, prevValue);\n          }); // don't onChange on programmatic changes\n        }\n      }, [componentValue, formValue, name]); // on unmount, if the form is uncontrolled, remove the key/value\n      // from the form value\n\n      useEffect(function () {\n        return function () {\n          if (keyCreated.current) {\n            keyCreated.current = false;\n            setValueState(function (prevValue) {\n              var nextValue = _extends({}, prevValue);\n\n              var isArrayField = stringToArray(name);\n\n              if (isArrayField) {\n                var arrayName = isArrayField.arrayName;\n                delete nextValue[arrayName];\n              } else {\n                delete nextValue[name];\n              }\n\n              return nextValue;\n            });\n          }\n        };\n      }, // eslint-disable-next-line react-hooks/exhaustive-deps\n      [] // only run onmount and unmount\n      );\n      useEffect(function () {\n        if (validateArg) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n\n          validationRulesRef.current[name].input = validateName(validateArg);\n          return function () {\n            return delete validationRulesRef.current[name].input;\n          };\n        }\n\n        return undefined;\n      }, [validateArg, name]);\n      var useValue;\n      if (componentValue !== undefined) // input component drives, pattern #2\n        useValue = componentValue;else if (valueProp && name && formValue !== undefined) // form drives, pattern #1\n        useValue = formValue;else if (formValue === undefined && name) // form has reset, so reset input value as well\n        useValue = initialValue;else useValue = inputValue;\n      return [useValue, function (nextComponentValue) {\n        if (name) {\n          // we have somewhere to put this\n          var nextTouched = _extends({}, touched);\n\n          nextTouched[name] = true;\n\n          if (!touched[name]) {\n            // don't update if not needed\n            setTouched(nextTouched);\n          } // if nextValue doesn't have a key for name, this must be\n          // uncontrolled form. we will flag this field was added so\n          // we know to remove its value from the form if it is dynamically\n          // removed\n\n\n          if (!(name in value)) keyCreated.current = true;\n          var nextValue = setFieldValue(name, nextComponentValue, value);\n          setValueState(nextValue);\n          if (onChange) onChange(nextValue, {\n            touched: nextTouched\n          });\n        }\n\n        if (initialValue !== undefined) setInputValue(nextComponentValue);\n      }];\n    };\n\n    var useFormField = function useFormField(_ref7) {\n      var errorArg = _ref7.error,\n          infoArg = _ref7.info,\n          name = _ref7.name,\n          required = _ref7.required,\n          disabled = _ref7.disabled,\n          validateArg = _ref7.validate;\n      var error = disabled ? undefined : errorArg || validationResults.errors[name];\n      var info = infoArg || validationResults.infos[name];\n      useEffect(function () {\n        var index = requiredFields.current.indexOf(name);\n\n        if (required) {\n          if (index === -1) requiredFields.current.push(name);\n        } else if (index !== -1) requiredFields.current.splice(index, 1);\n\n        if (validateArg || required) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n\n          validationRulesRef.current[name].field = validateName(validateArg, required);\n          return function () {\n            return delete validationRulesRef.current[name].field;\n          };\n        }\n\n        return undefined;\n      }, [error, name, required, validateArg, disabled]);\n      return {\n        error: error,\n        info: info,\n        inForm: true,\n        onBlur: validateOn === 'blur' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined,\n        onChange: validateOn === 'change' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined\n      };\n    };\n\n    return {\n      useFormField: useFormField,\n      useFormInput: useFormInput\n    };\n  }, [onChange, pendingValidation, touched, validateOn, validationResults.errors, validationResults.infos, value, valueProp]);\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: ref\n  }, rest, {\n    onReset: function onReset(event) {\n      setPendingValidation(undefined);\n\n      if (!valueProp) {\n        setValueState(defaultValue);\n        if (onChange) onChange(defaultValue, {\n          touched: defaultTouched\n        });\n      }\n\n      setTouched(defaultTouched);\n      setValidationResults(defaultValidationResults);\n\n      if (_onReset) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = defaultValue;\n\n        _onReset(adjustedEvent);\n      }\n    },\n    onSubmit: function onSubmit(event) {\n      // Don't submit the form via browser form action. We don't want it\n      // if the validation fails. And, we assume a javascript action handler\n      // otherwise.\n      event.preventDefault();\n      setPendingValidation(undefined);\n\n      var _validateForm4 = validateForm(Object.entries(validationRulesRef.current), value, format, messages, true),\n          nextErrors = _validateForm4[0],\n          nextInfos = _validateForm4[1];\n\n      setValidationResults(function () {\n        var nextValidationResults = {\n          errors: nextErrors,\n          infos: nextInfos,\n          // Show form's validity when clicking on Submit\n          valid: buildValid(nextErrors)\n        };\n        if (onValidate) onValidate(nextValidationResults);\n        return nextValidationResults;\n      });\n\n      if (Object.keys(nextErrors).length === 0 && _onSubmit) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = value;\n        adjustedEvent.touched = touched;\n\n        _onSubmit(adjustedEvent);\n      }\n    }\n  }), /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: formContextValue\n  }, children));\n});\nForm.displayName = 'Form';\nForm.propTypes = FormPropTypes;\nexport { Form };","map":{"version":3,"sources":["C:/Users/Naila/Desktop/projekatSi/frontend/node_modules/grommet/es6/components/Form/Form.js"],"names":["_excluded","_objectWithoutPropertiesLoose","source","excluded","target","sourceKeys","Object","keys","key","i","length","indexOf","_extends","assign","arguments","prototype","hasOwnProperty","call","apply","React","forwardRef","useCallback","useContext","useEffect","useMemo","useRef","useState","MessageContext","FormContext","FormPropTypes","defaultValue","defaultTouched","defaultValidationResults","errors","infos","stringToArray","string","match","arrayName","indexOfArray","arrayObjName","undefined","getFieldValue","name","value","isArrayField","_value$arrayName","obj","setFieldValue","componentValue","prevValue","nextValue","_nextValue$arrayName$","validate","rule","fieldValue","formValue","format","messages","result","regexp","test","message","id","status","validateName","validationRules","required","validationResult","Array","isArray","some","validator","validateForm","omitValid","nextErrors","nextInfos","forEach","_ref","_ref$","field","input","Form","_ref2","ref","children","_ref2$errors","errorsProp","_ref2$infos","infosProp","onChange","_onReset","onReset","_onSubmit","onSubmit","onValidate","_ref2$validate","validateOn","valueProp","rest","_useContext","_useState","valueState","setValueState","_useState2","touched","setTouched","_useState3","validationResults","setValidationResults","_useState4","pendingValidation","setPendingValidation","validationRulesRef","requiredFields","buildValid","valid","current","filter","n","includes","every","filterRemovedFields","prevValidations","nextValidations","validationsForSetFields","entries","_ref3","_validateForm","nextValidationResults","timer","setTimeout","_validateForm2","_ref4","validatedErrors","validatedInfos","prevValidationResults","clearTimeout","_validateForm3","_ref5","formContextValue","useFormInput","_ref6","initialValue","validateArg","_useState5","inputValue","setInputValue","keyCreated","useValue","nextComponentValue","nextTouched","useFormField","_ref7","errorArg","error","infoArg","info","disabled","index","push","splice","inForm","onBlur","concat","createElement","event","persist","adjustedEvent","preventDefault","_validateForm4","Provider","displayName","propTypes"],"mappings":"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","sourcesContent":["var _excluded = [\"children\", \"errors\", \"infos\", \"messages\", \"onChange\", \"onReset\", \"onSubmit\", \"onValidate\", \"validate\", \"value\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { FormContext } from './FormContext';\nimport { FormPropTypes } from './propTypes';\nvar defaultValue = {};\nvar defaultTouched = {};\nvar defaultValidationResults = {\n  errors: {},\n  infos: {}\n};\n\nvar stringToArray = function stringToArray(string) {\n  var match = string == null ? void 0 : string.match(/^(.+)\\[([0-9]+)\\]\\.(.*)$/);\n\n  if (match) {\n    var arrayName = match[1],\n        indexOfArray = match[2],\n        arrayObjName = match[3];\n    return {\n      indexOfArray: indexOfArray,\n      arrayName: arrayName,\n      arrayObjName: arrayObjName\n    };\n  }\n\n  return undefined;\n};\n\nvar getFieldValue = function getFieldValue(name, value) {\n  var isArrayField = stringToArray(name);\n\n  if (isArrayField) {\n    var _value$arrayName;\n\n    var indexOfArray = isArrayField.indexOfArray,\n        arrayName = isArrayField.arrayName,\n        arrayObjName = isArrayField.arrayObjName;\n    var obj = (_value$arrayName = value[arrayName]) == null ? void 0 : _value$arrayName[indexOfArray];\n    return arrayObjName ? obj == null ? void 0 : obj[arrayObjName] : obj;\n  }\n\n  return value[name];\n};\n\nvar setFieldValue = function setFieldValue(name, componentValue, prevValue) {\n  var nextValue = _extends({}, prevValue);\n\n  var isArrayField = stringToArray(name);\n\n  if (isArrayField) {\n    var indexOfArray = isArrayField.indexOfArray,\n        arrayName = isArrayField.arrayName,\n        arrayObjName = isArrayField.arrayObjName;\n    if (!nextValue[arrayName]) nextValue[arrayName] = [];\n\n    if (arrayObjName) {\n      var _nextValue$arrayName$;\n\n      if (!nextValue[arrayName][indexOfArray]) nextValue[arrayName][indexOfArray] = (_nextValue$arrayName$ = {}, _nextValue$arrayName$[arrayObjName] = componentValue, _nextValue$arrayName$);\n      nextValue[arrayName][indexOfArray][arrayObjName] = componentValue;\n    } else nextValue[arrayName][indexOfArray] = componentValue;\n  } else {\n    nextValue[name] = componentValue;\n  }\n\n  return nextValue;\n}; // Apply validation rule to field value and send correct messaging.\n\n\nvar validate = function validate(rule, fieldValue, formValue, format, messages) {\n  var result;\n\n  if (typeof rule === 'function') {\n    result = rule(fieldValue, formValue);\n  } else if (rule.regexp) {\n    if (!rule.regexp.test(fieldValue)) {\n      result = rule.message || format({\n        id: 'form.invalid',\n        messages: messages\n      });\n\n      if (rule.status) {\n        result = {\n          message: result,\n          status: rule.status\n        };\n      }\n    }\n  }\n\n  return result;\n}; // Validates particular key in formValue\n\n\nvar validateName = function validateName(validationRules, required) {\n  return function (name, formValue, format, messages) {\n    var fieldValue = getFieldValue(name, formValue);\n    var validationResult; // ValidateArg is something that gets passed in from a FormField component\n    // See 'validate' prop in FormField\n\n    if (required && ( // false is for CheckBox\n    fieldValue === undefined || fieldValue === '' || fieldValue === false || Array.isArray(fieldValue) && !fieldValue.length)) {\n      // There is no value at that name, and one is required\n      validationResult = format({\n        id: 'form.required',\n        messages: messages\n      });\n    } else if (validationRules) {\n      if (Array.isArray(validationRules)) {\n        validationRules.some(function (validator) {\n          validationResult = validate(validator, fieldValue, formValue, format, messages);\n          return !!validationResult;\n        });\n      } else {\n        validationResult = validate(validationRules, fieldValue, formValue, format, messages);\n      }\n    }\n\n    return validationResult;\n  };\n}; // validations is an array from Object.entries()\n// Validates all keys in formValue\n\n\nvar validateForm = function validateForm(validationRules, formValue, format, messages, omitValid) {\n  var nextErrors = {};\n  var nextInfos = {};\n  validationRules.forEach(function (_ref) {\n    var name = _ref[0],\n        _ref$ = _ref[1],\n        field = _ref$.field,\n        input = _ref$.input;\n\n    if (!omitValid) {\n      nextErrors[name] = undefined;\n      nextInfos[name] = undefined;\n    }\n\n    var result;\n\n    if (input) {\n      // input() a validation function supplied through useFormInput()\n      result = input(name, formValue, format, messages);\n    }\n\n    if (field && !result) {\n      // field() a validation function supplied through useFormField()\n      result = field(name, formValue, format, messages);\n    } // typeof error === 'object' is implied for both cases of error with\n    // a status message and for an error object that is a react node\n\n\n    if (typeof result === 'object') {\n      if (result.status === 'info') {\n        nextInfos[name] = result.message;\n      } else {\n        nextErrors[name] = result.message || result; // could be a node\n      }\n    } else if (typeof result === 'string') {\n      nextErrors[name] = result;\n    }\n  });\n  return [nextErrors, nextInfos];\n};\n\nvar Form = /*#__PURE__*/forwardRef(function (_ref2, ref) {\n  var children = _ref2.children,\n      _ref2$errors = _ref2.errors,\n      errorsProp = _ref2$errors === void 0 ? defaultValidationResults.errors : _ref2$errors,\n      _ref2$infos = _ref2.infos,\n      infosProp = _ref2$infos === void 0 ? defaultValidationResults.infos : _ref2$infos,\n      messages = _ref2.messages,\n      onChange = _ref2.onChange,\n      _onReset = _ref2.onReset,\n      _onSubmit = _ref2.onSubmit,\n      onValidate = _ref2.onValidate,\n      _ref2$validate = _ref2.validate,\n      validateOn = _ref2$validate === void 0 ? 'submit' : _ref2$validate,\n      valueProp = _ref2.value,\n      rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n  var _useContext = useContext(MessageContext),\n      format = _useContext.format;\n\n  var _useState = useState(valueProp || defaultValue),\n      valueState = _useState[0],\n      setValueState = _useState[1];\n\n  var value = useMemo(function () {\n    return valueProp || valueState;\n  }, [valueProp, valueState]);\n\n  var _useState2 = useState(defaultTouched),\n      touched = _useState2[0],\n      setTouched = _useState2[1];\n\n  var _useState3 = useState(defaultValidationResults),\n      validationResults = _useState3[0],\n      setValidationResults = _useState3[1]; // when onBlur input validation is triggered, we need to complete any\n  // potential click events before running the onBlur validation.\n  // otherwise, click events like reset, etc. may not be registered.\n  // for a detailed scenario/discussion,\n  // see: https://github.com/grommet/grommet/issues/4863\n  // the value of pendingValidation is the name of the FormField\n  // awaiting validation.\n\n\n  var _useState4 = useState(undefined),\n      pendingValidation = _useState4[0],\n      setPendingValidation = _useState4[1];\n\n  useEffect(function () {\n    setPendingValidation(undefined);\n    setValidationResults({\n      errors: errorsProp,\n      infos: infosProp\n    });\n  }, [errorsProp, infosProp]);\n  var validationRulesRef = useRef({});\n  var requiredFields = useRef([]);\n  var buildValid = useCallback(function (nextErrors) {\n    var valid = false;\n    valid = requiredFields.current.filter(function (n) {\n      return Object.keys(validationRulesRef.current).includes(n);\n    }).every(function (field) {\n      return value[field] && (value[field] !== '' || value[field] !== false);\n    });\n    if (Object.keys(nextErrors).length > 0) valid = false;\n    return valid;\n  }, [value]); // Only keep validation results for current form fields. In the case of a\n  // dynamic form, a field possessing an error may have been removed from the\n  // form; need to clean up any previous related validation results.\n\n  var filterRemovedFields = function filterRemovedFields(prevValidations) {\n    var nextValidations = prevValidations;\n    return Object.keys(nextValidations).filter(function (n) {\n      return !validationRulesRef.current[n] || nextValidations[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextValidations[n];\n    });\n  }; // On initial mount, when validateOn is change or blur,\n  // set validation results for any set fields and calculate whether\n  // the form is valid overall.\n\n\n  useEffect(function () {\n    var validationsForSetFields = Object.entries(validationRulesRef.current).filter(function (_ref3) {\n      var n = _ref3[0];\n      return getFieldValue(n, value);\n    });\n\n    if (validationsForSetFields.length > 0 && validateOn !== 'submit') {\n      var _validateForm = validateForm(validationsForSetFields, value, format, messages),\n          errors = _validateForm[0],\n          infos = _validateForm[1];\n\n      filterRemovedFields(errors);\n      filterRemovedFields(infos);\n      var nextValidationResults = {\n        errors: errors,\n        infos: infos,\n        valid: buildValid(errors)\n      };\n      if (onValidate) onValidate(nextValidationResults);\n      setValidationResults(nextValidationResults);\n    } // We only want to run this for the value we have on initial mount.\n    // We don't want subsequent changes to the value to re-run this.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []); // Currently, onBlur validation will trigger after a timeout of 120ms.\n\n  useEffect(function () {\n    var timer = setTimeout(function () {\n      if (pendingValidation) {\n        // run validations on the pending one and any other touched fields\n        var _validateForm2 = validateForm(Object.entries(validationRulesRef.current).filter(function (_ref4) {\n          var n = _ref4[0];\n          return touched[n] || pendingValidation.includes(n);\n        }), value, format, messages),\n            validatedErrors = _validateForm2[0],\n            validatedInfos = _validateForm2[1];\n\n        setPendingValidation(undefined);\n        setValidationResults(function (prevValidationResults) {\n          // keep any previous errors and infos for untouched keys,\n          // these may have come from a submit\n          var nextErrors = _extends({}, prevValidationResults.errors, validatedErrors);\n\n          var nextInfos = _extends({}, prevValidationResults.infos, validatedInfos);\n\n          filterRemovedFields(nextErrors);\n          filterRemovedFields(nextInfos);\n          var nextValidationResults = {\n            errors: nextErrors,\n            infos: nextInfos,\n            valid: buildValid(nextErrors)\n          };\n          if (onValidate) onValidate(nextValidationResults);\n          return nextValidationResults;\n        });\n      } // a timeout is needed to ensure that a click event (like one on a reset\n      // button) completes prior to running the validation. without a timeout,\n      // the blur will always complete and trigger a validation prematurely\n      // The following values have been empirically tested, but 120 was\n      // selected because it is the largest value\n      // Chrome: 100, Safari: 120, Firefox: 80\n\n    }, 120);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [buildValid, format, messages, pendingValidation, onValidate, touched, value, requiredFields]); // clear any errors when value changes\n\n  useEffect(function () {\n    if (validateOn !== 'change') setPendingValidation(undefined);\n    setValidationResults(function (prevValidationResults) {\n      var _validateForm3 = validateForm(Object.entries(validationRulesRef.current).filter(function (_ref5) {\n        var n = _ref5[0];\n        return prevValidationResults.errors[n] || prevValidationResults.infos[n];\n      }), value, format, messages),\n          nextErrors = _validateForm3[0],\n          nextInfos = _validateForm3[1];\n\n      return {\n        errors: _extends({}, prevValidationResults.errors, nextErrors),\n        infos: _extends({}, prevValidationResults.infos, nextInfos)\n      };\n    });\n  }, [format, messages, touched, validateOn, value]); // There are three basic patterns of handling form input value state:\n  //\n  // 1 - form controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the Form component to supply the values used by the input fields.\n  // In useFormContext(), componentValue would be undefined and formValue\n  // is be set to whatever the form state has. Whenever the form state\n  // changes, we update the contextValue so the input component will use\n  // that. When the input component changes, we will call update() to\n  // update the form state.\n  //\n  // 2 - input controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the input components, like TextInput, to supply the value for it.\n  // In useFormContext(), componentValue is this value and we ensure to\n  // update the form state, via update(), and set the contextValue from\n  // the componentValue. When the input component changes, we will\n  // call update() to update the form state.\n  //\n  // 3 - uncontrolled\n  //\n  // In this model, the caller doesn't set a `value` or `onChange` property\n  // at either the form or input component levels.\n  // In useFormContext(), componentValue is undefined and valueProp is\n  // undefined and nothing much happens here. That is, unless the\n  // calling component needs to know the state in order to work, such\n  // as CheckBox or Select. In this case, those components supply\n  // an initialValue, which will trigger updating the contextValue so\n  // they can have access to it.\n  //\n\n  var formContextValue = useMemo(function () {\n    var useFormInput = function useFormInput(_ref6) {\n      var name = _ref6.name,\n          componentValue = _ref6.value,\n          initialValue = _ref6.initialValue,\n          validateArg = _ref6.validate;\n\n      var _useState5 = useState(initialValue),\n          inputValue = _useState5[0],\n          setInputValue = _useState5[1];\n\n      var formValue = name ? getFieldValue(name, value) : undefined; // for dynamic forms, we need to track when an input has been added to\n      // the form value. if the input is unmounted, we will delete its\n      // key/value from the form value.\n\n      var keyCreated = useRef(false); // This effect is for pattern #2, where the controlled input\n      // component is driving the value via componentValue.\n\n      useEffect(function () {\n        if (name && // we have somewhere to put this\n        componentValue !== undefined && // input driving\n        componentValue !== formValue // don't already have it\n        ) {\n          setValueState(function (prevValue) {\n            return setFieldValue(name, componentValue, prevValue);\n          }); // don't onChange on programmatic changes\n        }\n      }, [componentValue, formValue, name]); // on unmount, if the form is uncontrolled, remove the key/value\n      // from the form value\n\n      useEffect(function () {\n        return function () {\n          if (keyCreated.current) {\n            keyCreated.current = false;\n            setValueState(function (prevValue) {\n              var nextValue = _extends({}, prevValue);\n\n              var isArrayField = stringToArray(name);\n\n              if (isArrayField) {\n                var arrayName = isArrayField.arrayName;\n                delete nextValue[arrayName];\n              } else {\n                delete nextValue[name];\n              }\n\n              return nextValue;\n            });\n          }\n        };\n      }, // eslint-disable-next-line react-hooks/exhaustive-deps\n      [] // only run onmount and unmount\n      );\n      useEffect(function () {\n        if (validateArg) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n\n          validationRulesRef.current[name].input = validateName(validateArg);\n          return function () {\n            return delete validationRulesRef.current[name].input;\n          };\n        }\n\n        return undefined;\n      }, [validateArg, name]);\n      var useValue;\n      if (componentValue !== undefined) // input component drives, pattern #2\n        useValue = componentValue;else if (valueProp && name && formValue !== undefined) // form drives, pattern #1\n        useValue = formValue;else if (formValue === undefined && name) // form has reset, so reset input value as well\n        useValue = initialValue;else useValue = inputValue;\n      return [useValue, function (nextComponentValue) {\n        if (name) {\n          // we have somewhere to put this\n          var nextTouched = _extends({}, touched);\n\n          nextTouched[name] = true;\n\n          if (!touched[name]) {\n            // don't update if not needed\n            setTouched(nextTouched);\n          } // if nextValue doesn't have a key for name, this must be\n          // uncontrolled form. we will flag this field was added so\n          // we know to remove its value from the form if it is dynamically\n          // removed\n\n\n          if (!(name in value)) keyCreated.current = true;\n          var nextValue = setFieldValue(name, nextComponentValue, value);\n          setValueState(nextValue);\n          if (onChange) onChange(nextValue, {\n            touched: nextTouched\n          });\n        }\n\n        if (initialValue !== undefined) setInputValue(nextComponentValue);\n      }];\n    };\n\n    var useFormField = function useFormField(_ref7) {\n      var errorArg = _ref7.error,\n          infoArg = _ref7.info,\n          name = _ref7.name,\n          required = _ref7.required,\n          disabled = _ref7.disabled,\n          validateArg = _ref7.validate;\n      var error = disabled ? undefined : errorArg || validationResults.errors[name];\n      var info = infoArg || validationResults.infos[name];\n      useEffect(function () {\n        var index = requiredFields.current.indexOf(name);\n\n        if (required) {\n          if (index === -1) requiredFields.current.push(name);\n        } else if (index !== -1) requiredFields.current.splice(index, 1);\n\n        if (validateArg || required) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n\n          validationRulesRef.current[name].field = validateName(validateArg, required);\n          return function () {\n            return delete validationRulesRef.current[name].field;\n          };\n        }\n\n        return undefined;\n      }, [error, name, required, validateArg, disabled]);\n      return {\n        error: error,\n        info: info,\n        inForm: true,\n        onBlur: validateOn === 'blur' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined,\n        onChange: validateOn === 'change' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined\n      };\n    };\n\n    return {\n      useFormField: useFormField,\n      useFormInput: useFormInput\n    };\n  }, [onChange, pendingValidation, touched, validateOn, validationResults.errors, validationResults.infos, value, valueProp]);\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: ref\n  }, rest, {\n    onReset: function onReset(event) {\n      setPendingValidation(undefined);\n\n      if (!valueProp) {\n        setValueState(defaultValue);\n        if (onChange) onChange(defaultValue, {\n          touched: defaultTouched\n        });\n      }\n\n      setTouched(defaultTouched);\n      setValidationResults(defaultValidationResults);\n\n      if (_onReset) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = defaultValue;\n\n        _onReset(adjustedEvent);\n      }\n    },\n    onSubmit: function onSubmit(event) {\n      // Don't submit the form via browser form action. We don't want it\n      // if the validation fails. And, we assume a javascript action handler\n      // otherwise.\n      event.preventDefault();\n      setPendingValidation(undefined);\n\n      var _validateForm4 = validateForm(Object.entries(validationRulesRef.current), value, format, messages, true),\n          nextErrors = _validateForm4[0],\n          nextInfos = _validateForm4[1];\n\n      setValidationResults(function () {\n        var nextValidationResults = {\n          errors: nextErrors,\n          infos: nextInfos,\n          // Show form's validity when clicking on Submit\n          valid: buildValid(nextErrors)\n        };\n        if (onValidate) onValidate(nextValidationResults);\n        return nextValidationResults;\n      });\n\n      if (Object.keys(nextErrors).length === 0 && _onSubmit) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = value;\n        adjustedEvent.touched = touched;\n\n        _onSubmit(adjustedEvent);\n      }\n    }\n  }), /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: formContextValue\n  }, children));\n});\nForm.displayName = 'Form';\nForm.propTypes = FormPropTypes;\nexport { Form };"]},"metadata":{},"sourceType":"module"}